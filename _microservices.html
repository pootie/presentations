<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>node.js microservices</title>

        <link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/kobold-logo.css">
        <link rel="stylesheet" href="css/theme/kobold-dark.css">
        <link rel="stylesheet" href="css/emoji.css">


		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
    <section id="kobold">
      <a href="https://www.kobold.com.au/">KoBold</a>
    </section>

		<div class="reveal">
			<div class="slides">
                <section>
                    <h2>Node.js Microservices</h2>
                    <p class="fragment"><i class="em em-metal"></i>Rad ideas and concepts<i class="em em-metal"></i></p>
                    <aside class="notes">
                        why should we consider a microservice architecture?
                    </aside>
                </section>
                <section>
                    <h4>State of the Stack</h4>
                    <img src="img/microservices-current-stack.jpg" />
                </section>
                <section>
                    <h4>To infinity and beyond!</h4>
                    <img src="img/microservices-future.jpg" />
                </section>
                <section>
                    <h4>Baby steps</h4>
                    <img src="img/microservices-next.jpg" />
                </section>
                <section>
                    <h2>Ideas from...</h2>
                    <img src="img/tao-microservices.jpg" width="30%" />
                    <aside class="notes">
                        The tao of microservices by Richard Rodger.
                        https://www.manning.com/books/the-tao-of-microservices
                    </aside>
                </section>

                <section>
                    <section>
                        <h2>What is Antifragile?</h2>
                        <img src="img/antifragile-book.jpg" height="60%" />
                        <aside class="notes">
                            Antifragile: Things That Gain From Disorder by Nassim Nicholas Taleb.
                            The exact opposite of fragile.
                        </aside>
                    </section>
                    <section data-background="img/fragile.jpg">
                        <h3>Fragile</h3>
                        <p>Porcelain teacup</p>
                        <p>House of cards</p>
                        <p>Monolithic code bases</p>
                        <aside class="notes">
                            Something that is easily damaged by stress and disorder.
                            Fragile things are overly optimized.
                        </aside>
                    </section>
                    <section data-background="img/resilient.jpg">
                        <h3>Resilient</h3>
                        <p>Big oak trees</p>
                        <p>A hammer</p>
                        <p>Cloud architecture</p>
                        <aside class="notes">
                            Something that stays the same during volatility.
                        </aside>
                    </section>
                    <section data-background="img/antifragile.jpg">
                        <h3>Antifragile</h3>
                        <p>The human body</p>
                        <p>Cities and economies</p>
                        <p>Ideas and movements</p>
                        <aside class="notes">
                            Something that grows stronger from volatility.
                        </aside>
                    </section>
                </section>

                <section data-background="img/atlantis-cockpit.jpg">
                    <p style="font-size: 9pt; position:absolute; right: 0; top:1680%;background-color:rgba(0, 0, 0, 0.7);">
                        https://www.nasa.gov/mission_pages/shuttle/flyout/flyfeature_shuttlecomputers.html
                    </p>
                    <aside class="notes">
                        Space Shuttle Atlantis. Flight software facts: 400 lines of code, 1 bug per release, $1000 per line of code.
                        As close as humanity has come to perfect software. Implicit assumption that enterpise software needs to be this perfect.
                        Processes. Fear. Unable to move fast.  Node.js apps will end up like older code bases (java, c#).
                    </aside>
                </section>
                <section data-background="img/gossamer_albatross.jpg">
                    <p style="font-size: 9pt; position:absolute; right: 0;top:1680%;background-color:rgba(0, 0, 0, 0.7);">
                        https://en.wikipedia.org/wiki/MacCready_Gossamer_Albatross
                    </p>
                    <aside class="notes">
                        The Gossamer Albatross, a human-powered aircraft built by Dr. Paul B. MacCready's company AeroVironment.
                        Â£100,000 prize offered in 1959 for flying under their own power across the English channel.
                        In 1979 it completed a successful crossing.
                        20 years. How? Problem wasn't crossing the channel, but not being able to iterate the design fast enough.
                        Using aluminium piping and mix and match parts he could iterate faster.
                        1 year to win prize after system was in place.
                        Node.js should be this empowering!
                    </aside>
                </section>
                <section data-background="img/yak.jpg">
                    <aside class="notes">
                        We've all met this Hymilayan Yak.
                        Node.js development is in danger of ending up like old school Enterpise Software Development.
                        You want to do something but you have to do all these other things that end up in having to shave a yak to get anything done.
                        RFC > Change Board Approval > Informal Test > Pre Prod Test > TRR > Formal Test > CIOG > Release Support > Shave Yak.
                    </aside>
                </section>
                <section data-background="img/lego.jpg">
                    <aside class="notes">
                        This is what we want Enterpise software development to be like.
                        Joyful. Ad for lego 1981.  We became software developers to feel this way.
                        Composabilty is hard to achieve. We need a component model for dealing with business logic.
                        Microservices.
                    </aside>
                </section>
                <section>
                    <h3>What is microservice?</h3>
                    <p>Small independent processes</p>
                    <p>Communicating via messages</p>
                    <p>A powerful component model</p>
                    <aside class="notes">
                        Deploy independently. Communication could be REST, message bus, anything.
                        Composable if you put them together in the right way.
                        Why each microservice should believe it's the only one in the world.
                    </aside>
                </section>
                <section>
                    <h3>Why microservices?</h3>
                    <p>Avoid technial debt</p>
                    <p>Continous Delivery</p>
                    <p>Build fast</p>
                    <aside class="notes">
                        They should be small. Deploy with Docker Swarm or Kubernetes. Composable.
                    </aside>
                </section>
                <section>
                    <h3>What are the trade offs?</h3>
                    <p>Deployment is more complex</p>
                    <p>Weird programming model</p>
                    <p>Services have to find each other</p>
                    <aside class="notes">
                        No free lunch. Use deployment tooling. Use tools to understand message flows (zipkin). Service discovery hard problem than deployment.
                        Why bother?
                    </aside>
                </section>
                <section>
                    <h4>Call me</h4>
                    <img src="img/microservices-component-call1.jpg" />
                    <aside class="notes">
                        Two components communicating. Could be an object, microservice, node modules etc.
                        The problem is the coupling between A and B.
                    </aside>
                </section>
                <section>
                    <h4>Coupling</h4>
                    <img src="img/microservices-component-call2.jpg" />
                    <aside class="notes">
                        Even if they are microservices using REST, there is a coupling.
                        It has to know the network location.
                        A has to know about B and that's a core weakness.
                        Building your entire system this way leads to a 'distributed' monolith as opposed to a regular monolith.
                    </aside>
                </section>
                <section>
                    <h4>Super Coupling!</h4>
                    <img src="img/classes.gif" />
                    <aside class="notes">
                        Making a change in a structure like this requires expert knowledge, technical reviews, change boards and shaving a yak!
                    </aside>
                </section>
                <section>
                    <h4>Un-Coupling?</h4>
                    <img src="img/microservices-component-call3.jpg" />
                    <aside class="notes">
                        But wait this is hope! This is the promised land. Each microservice/component should believe it's the only one.
                    </aside>
                </section>
                <section>
                    <h4>Decoupled!</h4>
                    <img src="img/microservices-component-decouple.jpg" />
                    <aside class="notes">
                        A sends a message without knowing location of B, B recieves messages without knowledge of A.
                        Now you have decoupling.  You can change A or B independent of each other.
                        New problem, how do we deal with service discovery?
                    </aside>
                </section>
                <section>
                    <h3>Service Discovery by...</h3>
                    <p>Configuration files</p>
                    <p>Intelligent load-balancing</p>
                    <p>Service registries</p>
                    <p>DNS</p>
                    <p>Message bus</p>
                    <aside class="notes">
                        All of these solutions still preserve the notion of identity.
                        What can we do?
                    </aside>
                </section>

                <section data-background="img/lamp.jpg">
                    <p><span style="background-color:rgba(0, 0, 0, 0.7);">What if service discovery didn't require identity?</span></p>
                </section>

                <section>
                    <h3>Pattern Matching</h3>
                    <p>Use message data to define patterns, and these patterns define a language.</p>
                    <h3>Transport Independence</h3>
                    <p>Services should not know about eachother, or how to send messages.</p>
                    <p>Services are fully defined by:</p>
                    <ul>
                        <li>message patterns they recognise, and</li>
                        <li>message patterns they emit.</li>
                    </ul>
                    <aside class="notes">
                        Pattern matching allows us to get away from the notion of service identity.
                        Services that care for a message respond to it.  In an ideal world every service would see every message,
                        but that is not practical in production.  In practice you need a peer-to-peer approach.
                    </aside>
                </section>

                <section>
                    <h3>The SWIM algorithm</h3>
                    <p>"Scalable Weakly-consistent Infection-style Process Group Membership Protocol"</p>
                    <p style="font-size: 9pt;"><a href="http://www.cs.cornell.edu/~asdas/research/dsn02-SWIM.pdf">http://www.cs.cornell.edu/~asdas/research/dsn02-SWIM.pdf</a></p>
                    <p>Designed for large scale (Uber)</p>
                    <p>Basic idea:</p>
                    <ul>
                        <li>each service pings a random subset of services (different each time)</li>
                        <li>the pings establish health and disseminate membership information</li>
                    </ul>
                    <aside class="notes">
                        Smart people have solved this problem. Cornell University.
                        Uber uses it for ~2000 services.
                        In other words it's magic!
                    </aside>
                </section>
                <section>
                    <img src="img/microservices-component-infect.jpg" />
                    <aside class="notes">
                        A joins network infects B, B then propagates this along and so on.
                        When you see it in practice, it feels like MAGIC!
                    </aside>
                </section>

                <section data-background="img/magic.gif">
                    <aside class="notes">
                        This MAGIC gives you some interesting options.
                    </aside>
                </section>

                <section>
                    <h3>Scale</h3>
                    <img src="img/microservices-component-scale.jpg" />
                    <aside class="notes">
                        Need more B? Add another service, round robin them.
                    </aside>
                </section>

                <section>
                    <h3>Deploy</h3>
                    <img src="img/microservices-component-deploy.jpg" />
                    <aside class="notes">
                        Individual parts can be removed from a running system. Add new B, move load to B, remove A, go home at 4:30pm.
                    </aside>
                </section>

                <section>
                    <h3>Composabilty</h3>
                    <img src="img/microservices-component-compose.jpg" />
                    <aside class="notes">
                        Combine services by observing message and passing them on.  A thinks it's talking to B, but we've added C. Could be a caching layer or something functionality.
                    </aside>
                </section>

                <section data-background="img/dragon-scroll.jpg">
                    <h3>Secret Sauce?</h3>
                    <p><a href="http://senecajs.org/"><img src="img/senecajs.jpg"/></a></p>
                    <p><a style="font-size: 0.6em;" href="http://senecajs.org/">http://senecajs.org</a> | <a style="font-size: 0.6em;" href="https://github.com/senecajs/ramanujan">Twitter in 14 microservices</a></p>
                    <aside class="notes">
                        Provides both the pattern matching and transport independence.
                    </aside>
                </section>
                <section data-background="img/demo.jpg">
                    <h2 style="background-color:rgba(0, 0, 0, 0.5);">Stop! Demo Time!</h2>
                    <p><a style="font-size: 0.6em;background-color:rgba(0, 0, 0, 0.5);" href="https://github.com/pootie/seneca-mesh-example">https://github.com/pootie/seneca-mesh-example</a></p>
                    <aside class="notes">
                        I can't take it anymore show me some me some magic!
                    </aside>
                </section>

                <section data-background="img/questions.jpg">
                    <h2 style="background-color:rgba(0, 0, 0, 0.5);">Questions?</h2>
                    <p><a style="font-size: 0.6em;background-color:rgba(0, 0, 0, 0.5);" href="https://github.com/pootie/presentations">this presentation (source)</a> | <a style="font-size: 0.6em;background-color:rgba(0, 0, 0, 0.5);" href="http://fabrik.kobold.com.au/presentations/_microservices.html">view here</a></p>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					// Zoom in and out with Alt+click
					{ src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/tagcloud/tagcloud.js' }
				]
			});
		</script>
	</body>
</html>
