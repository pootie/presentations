<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>node.js microservices</title>

    <link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/kobold-logo.css">
		<link rel="stylesheet" href="css/theme/kobold-dark.css">


		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
    <section id="kobold">
      <a href="https://www.kobold.com.au/">KoBold</a>
    </section>

		<div class="reveal">
			<div class="slides">
                <section>
                    <h2>Node.js Microservices</h2>
                    <p>Closer to Antifagile</p>
                    <aside class="notes">
                        why microservice architecture?
                    </aside>
                </section>
                <section>
                    <section>
                        <h2>What is Antifragile?</h2>
                        <img src="img/antifragile-book.jpg" height="60%" />
                        <aside class="notes">
                            Antifragile: Things That Gain From Disorder by Nassim Nicholas Taleb.
                            The exact opposite of fragile.
                        </aside>
                    </section>
                    <section data-background="img/fragile.jpg">
                        <h3>Fragile</h3>
                        <p>Porcelain teacup</p>
                        <p>House of cards</p>
                        <p>Monolithic code bases</p>
                        <aside class="notes">
                            Something that is easily damaged by stress and disorder.
                            Fragile things are overly optimized.
                        </aside>
                    </section>
                    <section data-background="img/resilient.jpg">
                        <h3>Resilient</h3>
                        <p>Big oak trees</p>
                        <p>A hammer</p>
                        <p>Cloud architecture</p>
                        <aside class="notes">
                            Something that stays the same during volatility.
                        </aside>
                    </section>
                    <section data-background="img/antifragile.jpg">
                        <h3>Antifragile</h3>
                        <p>The human body</p>
                        <p>Cities and economies</p>
                        <p>Ideas</p>
                        <aside class="notes">
                            Something that grows stronger from volatility.  
                        </aside>
                    </section>
                </section>
                
                <section data-background="img/atlantis-cockpit.jpg">
                    <p style="font-size: 9pt; position:absolute; right: 0; top:1680%;background-color:rgba(0, 0, 0, 0.7);">
                        https://www.nasa.gov/mission_pages/shuttle/flyout/flyfeature_shuttlecomputers.html
                    </p>
                    <aside class="notes">
                        Space Shuttle Atlantis. Flight software facts: 400 lines of code, 1 bug per release, $1000 per line of code.
                        As close as humanity has come to perfect software. Implicit assumption that enterpise software needs to be this perfect.
                        Processes. Fear. Unable to move fast.  Node.js apps will end up like older code bases (java, c#).
                    </aside>
                </section>
                <section data-background="img/gossamer_albatross.jpg">
                    <p style="font-size: 9pt; position:absolute; right: 0;top:1680%;background-color:rgba(0, 0, 0, 0.7);">
                        https://en.wikipedia.org/wiki/MacCready_Gossamer_Albatross
                    </p>
                    <aside class="notes">
                        The Gossamer Albatross, a human-powered aircraft built by Dr. Paul B. MacCready's company AeroVironment.
                        Â£100,000 prize offered in 1959 for flying under their own power across the English channel. 
                        In 1979 it completed a successful crossing.
                        20 years. How? Problem wasn't crossing the channel, but not being able to iterate the design fast enough.
                        Using aluminium piping and mix and match parts he could iterate faster.
                        1 year to win prize after system was in place.
                        Node.js should be this empowering!
                    </aside>
                </section>
                <section data-background="img/yak.jpg">
                    <aside class="notes">
                        Node.js development is in danger of ending up like old school Enterpise Software Development 
                        which can feel like shaving a Himilayan Yak.
                        You want to do something but you have to do all these other things that end up in having to shave a yak to get anything done.
                    </aside>
                </section>
                <section data-background="img/lego.jpg">
                    <aside class="notes">
                        This is what we want Enterpise software development to be like.
                        Joyful. Ad for lego 1981.  We became software developers to feel this way.
                        Composabilty is hard to achieve. We need a component model for dealing with business logic.
                        Microservices.
                    </aside>
                </section>
                <section>
                    <h3>What is microservice?</h3>
                    <p>Small independent processes</p>
                    <p>Communicating via messages</p>
                    <p>A powerful component model</p>
                    <aside class="notes">
                        Deploy independently. Communication could be REST, message bus, anything. 
                        Composable if you put them together in the right way. 
                        Why each microservice should believe it's the only one in the world.                        
                    </aside>
                </section>
                <section>
                    <h3>Why microservices?</h3>
                    <p>Avoid technial debt</p>
                    <p>Continous Delivery</p>
                    <p>Build fast</p>
                    <aside class="notes">
                        The should be small. Docker or Kubernetes. Composable.
                    </aside>
                </section>
                <section>
                    <h3>What are the trade offs?</h3>
                    <p>Deployment is more complex</p>
                    <p>Weird programming model</p>
                    <p>Services have to find each other</p>
                    <aside class="notes">
                        No free lunch. Use tools to understand message flows (zipkin). Service discovery hard problem than deployment.
                    </aside>
                </section>
                <section>
                    <img src="img/microservices-component-call1.jpg" />
                    <aside class="notes">
                        Two components communicating. Could be an object, microservice, node modules etc.
                        The problem is the coupling between A and B.
                    </aside>
                </section>
                <section>
                    <img src="img/microservices-component-call2.jpg" />
                    <aside class="notes">
                        Even if they are microservices using REST, there is a coupling.  
                        It has to know the network location on the network.
                        A has to know about B and that's a core weakness.  
                        Building your entire system this way leads to a distributed monolith.
                    </aside>
                </section>
                <section>
                    <img src="img/microservices-component-call3.jpg" />
                    <aside class="notes">
                        This is the promised land. Each microservice should believe it's the only one.
                        A sends a message without knowing location of B, B recieves messages without knowledge of A.
                        Now you have decoupling.  You can change A or B independent of each other. 
                        How do we deal with service discovery?                       
                    </aside>
                </section>  
                <section>
                    <h3>Service Discovery by...</h3>
                    <p>Configuration files</p>
                    <p>Intelligent load-balancing</p>
                    <p>Service registries</p>
                    <p>DNS</p>
                    <p>Message bus</p>
                    <aside class="notes">
                        All of these solutions still preserve the notion of identity.
                        What can we do? 
                    </aside>
                </section>                              

                <section data-background="img/lamp.jpg">
                    <p><span style="background-color:rgba(0, 0, 0, 0.7);">What if service discovery didn't require identity?</span></p>
                </section>

                <section>
                    <h3>Pattern Matching</h3>
                    <p>Use message data to define patterns, and these patterns define a language.</p>
                    <h3>Transport Independence</h3>
                    <p>Services should not know about eachother, or how to send messages.</p>
                    <p>Services are fully defined by:</p>
                    <ul>
                        <li>message patterns they recognise, and</li>
                        <li>message patterns they emit.</li>
                    </ul>
                    <aside class="notes">
                        Pattern matching allows us to get away from the notion of service identity.
                        Services that care for a message respond to it.  In an ideal world every service would see every message, 
                        but that is not practical in production.  In practice you need a peer-to-peer approach.
                    </aside>
                </section>  

                <section>
                    <h3>The SWIM algorithm</h3>
                    <p>"Scalable Weakly-consistent Infection-style Process Group Membership Protocol"</p>
                    <p style="font-size: 9pt;"><a href="http://www.cs.cornell.edu/~asdas/research/dsn02-SWIM.pdf">http://www.cs.cornell.edu/~asdas/research/dsn02-SWIM.pdf</a></p>
                    <p>Designed for large scale (Uber)</p>
                    <p>Basic idea:</p>
                    <ul>
                        <li>each service pangs a random subset of services (different each time)</li>
                        <li>the pings establish health and disseminate membership information</li>
                    </ul>                    
                    <aside class="notes">
                        Uber uses it for ~2000 services.
                        In other words it's magic!
                    </aside>
                </section>  
                <section>
                    <img src="img/microservices-component-infect.jpg" />
                    <aside class="notes">
                        A joins network infects B, B then propagates this along and so on.  
                        When you see it in practice, it feels like MAGIC!
                    </aside>
                </section>                
                
                <section data-background="img/magic.gif">
                    <aside class="notes">
                        This MAGIC gives you some interesting options.
                    </aside>                    
                </section>

                <section>
                    <h3>Scale</h3>
                    <img src="img/microservices-component-scale.jpg" />
                    <aside class="notes">
                        Add another service, round robin them.
                    </aside>
                </section>  
                
                <section>
                    <h3>Deploy</h3>
                    <img src="img/microservices-component-deploy.jpg" />
                    <aside class="notes">
                        Individual parts can be removed from a running system.
                    </aside>
                </section>   
                
                <section>
                    <h3>Composabilty</h3>
                    <img src="img/microservices-component-compose.jpg" />
                    <aside class="notes">
                        A thinks it's talking to B, but we've added C. Could be a caching layer or something functionality.
                    </aside>
                </section>                 

                <section data-background="img/dragon-scroll.jpg">
                    <h2>Secret Sauce?</h2>
                    <p><a href="http://senecajs.org/"><img src="img/senecajs.jpg"/></a></p>
                    <p><a style="font-size: 0.6em;" href="http://senecajs.org/">http://senecajs.org</a> |  <a style="font-size: 0.6em;" href="https://github.com/senecajs/ramanujan">Twitter in 14 microservices</a></p>
                    <aside class="notes">
                        Provides both the pattern matching and transport independence.
                    </aside>                    
                </section>
                <section data-background="img/demo.jpg">
                    <h2 style="background-color:rgba(0, 0, 0, 0.5);">Stop! Demo Time!</h2>
                </section>

                <section data-background="img/questions.jpg">
                    <h2 style="background-color:rgba(0, 0, 0, 0.5);">Questions?</h2>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					// Zoom in and out with Alt+click
					{ src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/tagcloud/tagcloud.js' }
				]
			});
		</script>
	</body>
</html>
